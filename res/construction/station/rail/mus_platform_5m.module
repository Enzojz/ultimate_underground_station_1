local func = require "entry/func"
local coor = require "entry/coor"
local pipe = require "entry/pipe"
local general = require "entry/general"
local station = require "mus/stationlib"
local mus = require "mus"
local dump = require "luadump"

local unpack = table.unpack
local ma = math
local pi = ma.pi

local segmentLength = 5
local platformWidth = 10
local platformHeight = 1.93
local edgeWidth = 0.8
local sideWidth = 1.7
local centralWidth = 5

local function makeSize(left, right)
    return {
        lb = coor.xyz(left, -2.5, 0),
        lt = coor.xyz(left, 2.5, 0),
        rt = coor.xyz(right, 2.5, 0),
        rb = coor.xyz(right, -2.5, 0)
    }
end

function data()
    return {
        availability = {
            yearFrom = 0,
            yearTo = 0,
        },
        buildMode = "SINGLE",
        cost = {
            price = 15000,
        },
        description = {
            name = _("5m Underground platform"),
            description = _("An underground platform of 5m wide"),
            icon = "ui/construction/street/underpass_entry.tga"
        },
        category = {
            categories = {"platform"},
        },
        type = "mus_platform",
        order = {
            value = 260,
        },
        metadata = {
            platform = true,
        },
        
        updateFn = function(result, transform, tag, slotId, addModelFn, params)
            local hW = 5
            local vectorW = func.interlace({
                -hW,
                - hW + edgeWidth,
                -hW + edgeWidth + sideWidth,
                hW - edgeWidth - sideWidth,
                hW - edgeWidth,
                hW
            })
            local vectorMW = {edgeWidth, sideWidth, (hW - edgeWidth - sideWidth) * 2, sideWidth, edgeWidth}
            local vectorM = {"edgeLeft", "left", "central", "right", "edgeRight"}
            dump()({vectorW, vectorMW, vectorM})
            local newModels = pipe.mapn(vectorW, vectorMW, vectorM)(function(w, mw, m)
                local size = makeSize(unpack(w))
                return {
                    station.newModel(result.modelType.platform[m] .. "_tl.mdl", mus.fitModel(mw, segmentLength, platformHeight, size, true, true)),
                    station.newModel(result.modelType.platform[m] .. "_br.mdl", mus.fitModel(mw, segmentLength, platformHeight, size, false, false))
                }
            end)
            
            result.models =
                pipe.new
                * result.models
                + func.flatten(newModels)
        end,
        
        getModelsFn = function(params)
            local hW = 5
            local vectorW = func.interlace({
                -hW
                - hW + edgeWidth,
                -hW + edgeWidth + sideWidth,
                hW - edgeWidth - sideWidth,
                hW - edgeWidth,
                hW
            })
            local vectorMW = {edgeWidth, sideWidth, (hW - edgeWidth - sideWidth) * 2, sideWidth, edgeWidth}
            local vectorM = {"edgeLeft", "left", "central", "right", "edgeRight"}
            
            return
                pipe.new
                * pipe.mapn(vectorW, vectorMW, vectorM)(function(w, mw, m)
                    local size = makeSize(unpack(w))
                    return {
                        station.newModel(m .. "_tl.mdl", mus.fitModel(mw, segmentLength, platformHeight, size, true, true)),
                        station.newModel(m .. "_br.mdl", mus.fitModel(mw, segmentLength, platformHeight, size, false, false))
                    }
                end)
                * pipe.flatten()
        end
    }

end
