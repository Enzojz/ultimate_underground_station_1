local func = require "entry/func"
local coor = require "entry/coor"
local pipe = require "entry/pipe"
local general = require "entry/general"
local station = require "mus/stationlib"
local mus = require "mus"
local quat = require "entry/quaternion"
local dump = require "luadump"

local unpack = table.unpack
local ma = math
local pi = ma.pi

local segmentLength = 5
local platformWidth = 10
local platformHeight = 1.93
local edgeWidth = 0.8
local sideWidth = 1.7
local centralWidth = 5

local function makeSize(left, right)
    return {
        lb = coor.xyz(left, -2.5, 0),
        lt = coor.xyz(left, 2.5, 0),
        rt = coor.xyz(right, 2.5, 0),
        rb = coor.xyz(right, -2.5, 0)
    }
end

local stairsWidth = 7

local arcGen = function(p, o) return {
    l = p.l(o),
    r = p.r(-o)
} end

local mc = function(lc, rc) return func.map2(lc, rc, function(l, r) return l:avg(r) end) end

local arcProfiles = function(config, arcs)
    local refZ = config.hPlatform
    local arcRef, arcL, arcR = unpack(arcs)
    local general = {
        l = arcL(refZ)(),
        r = arcR(refZ)()
    }
    
    local arcs = {
        platform = {
            lane = arcGen(general, 0.6),
            edge = arcGen(general, -0.5),
            central = arcGen(general, 0.3)
        },
        ceil = {
            edge = arcGen(general, -0.5),
            central = arcGen(general, 0.2),
        },
        stairs = {
            outer = arcGen(general, (platformWidth - stairsWidth) * 0.5 + 0.3),
            inner = arcGen(general, (platformWidth - stairsWidth) * 0.5 + 0.55)
        },
        terrain = arcGen({
            l = arcL(refZ + 7.75)(function(l) return l + 5 end),
            r = arcR(refZ + 7.75)(function(l) return l + 5 end)
        }, -0.5)
    }
    
    local lsc, rsc, lsuc, rsuc, lc, rc, lpc, rpc, lpic, rpic, lsoc, rsoc, lsic, rsic, c = mus.biLatCoords(5)(
        arcs.platform.edge.l, arcs.platform.edge.r,
        arcs.platform.central.l, arcs.platform.central.r,
        arcs.platform.lane.l, arcs.platform.lane.r,
        arcs.ceil.edge.l, arcs.ceil.edge.r,
        arcs.ceil.central.l, arcs.ceil.central.r,
        arcs.stairs.outer.l, arcs.stairs.outer.r,
        arcs.stairs.inner.l, arcs.stairs.inner.r
    )
    local tlc, trc, tc = mus.biLatCoords(5)(arcs.terrain.l, arcs.terrain.r)
    return {
        [1] = arcL,
        [2] = arcR,
        [3] = arcRef,
        count = c,
        platform = {
            edge = func.with(arcs.platform.edge, {lc = lsc, rc = rsc, mc = mc(lsc, rsc), c = c}),
            central = func.with(arcs.platform.central, {lc = lsuc, rc = rsuc, mc = mc(lsuc, rsuc), c = c}),
            lane = func.with(arcs.platform.lane, {lc = lc, rc = rc, mc = mc(lc, rc), c = c})
        },
        ceil = {
            edge = func.with(arcs.ceil.edge, {lc = lpc, rc = rpc, mc = mc(lpc, rpc), c = c}),
            central = func.with(arcs.ceil.central, {lc = lpic, rc = rpic, mc = mc(lpic, rpic), c = c}),
        },
        stairs = {
            outer = func.with(arcs.stairs.outer, {lc = lsoc, rc = rsoc, mc = mc(lsoc, rsoc), c = c}),
            inner = func.with(arcs.stairs.inner, {lc = lsic, rc = rsic, mc = mc(lsic, rsic), c = c}),
        },
        terrain = func.with(arcs.terrain, {lc = tlc, rc = trc, mc = mc(tlc, trc), c = tc}),
        isPlatform = true
    }

end


local buildSurface = function(fitModel, config, platformZ, tZ)
    return function(c, w, fnSize)
        local fnSize = fnSize or function(_, lc, rc) return mus.assembleSize(lc, rc) end
        return function(i, s, ...)
            local sizeS = fnSize(i, ...)
            
            return s
                and pipe.new
                / station.newModel(s .. "_tl.mdl", tZ, fitModel(w, 5, platformZ, sizeS, true, true))
                / station.newModel(s .. "_br.mdl", tZ, fitModel(w, 5, platformZ, sizeS, false, false))
                or pipe.new * {}
        end
    end
end

local il = pipe.interlace({"s", "i"})

local platform = function(config, arcs, fitModel)
    local tZ = coor.transZ(config.hPlatform - 1.4)-- model height = 1.93 - 1.4 -> 0.53 -> adjust model level to rail level
    local platformZ = config.hPlatform + 0.53 --target Z

    local buildPlatform = buildSurface(fitModel, config, platformZ, tZ)
    local buildCeil = buildSurface(fitModel, config, platformZ, coor.I())
    local buildWall = buildSurface(fitModel, config, platformZ, coor.scaleZ(5 - platformZ) * coor.transZ(platformZ))
    

    local c = arcs.count
    local cModels = 2 * c - 2
    local indices = func.seq(1, cModels)
    local fnModels = function(normal, down, upA, upB)
        local fn = function(i)
            return normal
            -- local posD, posA, posB = stepPos(i)
            -- if posD then return down
            -- elseif posA then return upA
            -- elseif posB then return upB
            -- else return normal end
        end
        return pipe.new * indices * pipe.map(fn)
    end
    
    local models = {
        platform = {
            left = pipe.rep(cModels)(config.models.platform.left),
            right = pipe.rep(cModels)(config.models.platform.right),
            edgeLeft = pipe.rep(cModels)(config.models.platform.edgeLeft),
            edgeRight = pipe.rep(cModels)(config.models.platform.edgeRight),
            central = pipe.rep(cModels)(config.models.platform.central)
        },
        
        stair = {
            central = fnModels(false, config.models.downstep.central, config.models.upstep.a, config.models.upstep.b),
            left = fnModels(false, config.models.downstep.left, config.models.upstep.aLeft, config.models.upstep.bLeft),
            right = fnModels(false, config.models.downstep.right, config.models.upstep.aRight, config.models.upstep.bRight),
            inner = fnModels(false, false, config.models.upstep.aInner, config.models.upstep.bInner),
            back = fnModels(false, config.models.downstep.back, false, config.models.upstep.back)
        },
        
        ceil = {
            left = fnModels(config.models.ceil.left, config.models.ceil.left, config.models.ceil.aLeft, config.models.ceil.bLeft),
            right = fnModels(config.models.ceil.right, config.models.ceil.right, config.models.ceil.aRight, config.models.ceil.bRight),
            edge = pipe.rep(cModels)(config.models.ceil.edge),
            central = fnModels(config.models.ceil.central, config.models.ceil.central, false, false)
        },
        
        top = {
            central = fnModels(config.models.top.platform.central, config.models.top.platform.central, false, false),
            left = pipe.rep(cModels)(config.models.top.platform.left),
            right = pipe.rep(cModels)(config.models.top.platform.right)
        }
    }
    
    local platforms = pipe.new
        + pipe.mapn(
            indices,
            models.platform.central,
            il(arcs.stairs.outer.lc), il(arcs.stairs.outer.rc)
        )(buildPlatform(c, 5, function(i, lc, rc) return
            i >= c
            and mus.assembleSize(lc, rc)
            or mus.assembleSize({s = rc.i, i = rc.s}, {s = lc.i, i = lc.s})
        end))
        + pipe.mapn(
            indices,
            models.platform.left,
            il(arcs.platform.central.lc), il(arcs.stairs.outer.lc)
        )(buildPlatform(c, 1.7))
        + pipe.mapn(
            indices,
            models.platform.right,
            il(arcs.stairs.outer.rc), il(arcs.platform.central.rc)
        )(buildPlatform(c, 1.7))
        + pipe.mapn(
            indices,
            models.platform.edgeLeft,
            il(arcs.platform.edge.lc), il(arcs.platform.central.lc)
        )(buildPlatform(c, 0.8))
        + pipe.mapn(
            indices,
            models.platform.edgeRight,
            il(arcs.platform.central.rc), il(arcs.platform.edge.rc)
        )(buildPlatform(c, 0.8))
    
    local ceils =
        pipe.new
        + pipe.mapn(
            indices,
            models.ceil.central,
            il(arcs.stairs.outer.lc), il(arcs.stairs.outer.rc)
        )(buildCeil(c, 5))
        + pipe.mapn(
            indices,
            models.ceil.left,
            il(arcs.ceil.central.lc), il(arcs.stairs.outer.lc)
        )(buildCeil(c, 1.8))
        + pipe.mapn(
            indices,
            models.ceil.right,
            il(arcs.stairs.outer.rc), il(arcs.ceil.central.rc)
        )(buildCeil(c, 1.8))
        + pipe.mapn(
            indices,
            models.ceil.edge,
            il(arcs.ceil.edge.lc), il(arcs.ceil.central.lc)
        )(buildCeil(c, 0.7))
        + pipe.mapn(
            indices,
            models.ceil.edge,
            il(func.rev(arcs.ceil.edge.rc)), il(func.rev(arcs.ceil.central.rc))
        )(buildCeil(c, 0.7))
    
    local tops = pipe.new
        + pipe.mapn(
            indices,
            models.top.central,
            il(arcs.stairs.outer.lc), il(arcs.stairs.outer.rc)
        )(buildCeil(c, 5))
        + pipe.mapn(
            indices,
            models.top.left,
            il(arcs.ceil.edge.lc), il(arcs.stairs.outer.lc)
        )(buildCeil(c, 2.5))
        + pipe.mapn(
            indices,
            models.top.right,
            il(arcs.stairs.outer.rc), il(arcs.ceil.edge.rc)
        )(buildCeil(c, 2.5))
    
    local extremity = pipe.mapn(
        {
            {arcs.ceil.edge.lc[1], arcs.ceil.central.lc[1]},
            {arcs.ceil.central.lc[1], arcs.ceil.central.rc[1]},
            {arcs.ceil.central.rc[1], arcs.ceil.edge.rc[1]},
            {arcs.ceil.central.lc[c * 2 - 1], arcs.ceil.edge.lc[c * 2 - 1]},
            {arcs.ceil.central.rc[c * 2 - 1], arcs.ceil.central.lc[c * 2 - 1]},
            {arcs.ceil.edge.rc[c * 2 - 1], arcs.ceil.central.rc[c * 2 - 1]},
        },
        {
            config.models.wallExtremityEdge .. "_left", config.models.wallExtremity, config.models.wallExtremityEdge .. "_right",
            config.models.wallExtremityEdge .. "_left", config.models.wallExtremity, config.models.wallExtremityEdge .. "_right"
        },
        {
            0.7, 8.6, 0.7,
            0.7, 8.6, 0.7
        }
    )
    (function(c, m, w)
        local lc, rc = unpack(c)
        local vec = rc - lc
        return station.newModel(m .. ".mdl",
            coor.scale(coor.xyz(vec:length() / w, 1, 5 - platformZ)),
            quat.byVec(coor.xyz(1, 0, 0), vec):mRot(),
            coor.trans(lc:avg(rc))
    )
    end)
    
    local extremityPlatform = pipe.mapn(
        {
            {arcs.ceil.edge.lc[1], arcs.ceil.central.lc[1]},
            {arcs.ceil.central.lc[1], arcs.ceil.edge.rc[1]},
            {arcs.ceil.edge.lc[c * 2 - 1], arcs.ceil.central.lc[c * 2 - 1]},
            {arcs.ceil.central.rc[c * 2 - 1], arcs.ceil.edge.rc[c * 2 - 1]},
        },
        {"l", "r", "r", "l"},
        {
            coor.I(), coor.I(),
            coor.rotZ(pi), coor.rotZ(pi)
        }
    )
    (function(c, p, r)
        local lc, rc = unpack(c)
        local vec = rc - lc
        return {
            station.newModel(config.models.wallExtremityPlatform .. "_" .. p .. ".mdl",
                coor.transZ(-platformZ),
                tZ, r,
                quat.byVec(coor.xyz(1, 0, 0), vec):mRot(),
                coor.trans(lc:avg(rc))
            ),
            station.newModel(config.models.wallExtremityTop .. "_" .. p .. ".mdl",
                coor.transZ(-platformZ),
                r,
                quat.byVec(coor.xyz(1, 0, 0), vec):mRot(),
                coor.trans(lc:avg(rc))
        )
        }
    end)
    
    return (pipe.new / platforms ) * pipe.flatten() * pipe.flatten() + extremity
end


function data()
    return {
        availability = {
            yearFrom = 0,
            yearTo = 0,
        },
        buildMode = "SINGLE",
        cost = {
            price = 15000,
        },
        description = {
            name = _("5m Underground platform"),
            description = _("An underground platform of 5m wide"),
            icon = "ui/construction/street/underpass_entry.tga"
        },
        category = {
            categories = {"platform"},
        },
        type = "mus_platform",
        order = {
            value = 260,
        },
        metadata = {
            platform = true,
            width = 5
        },
        
        updateFn = function(result, transform, tag, slotId, addModelFn, params)
            local allArcs = arcProfiles(result.config, result.arcs[slotId])
            local newModels = platform(result.config, allArcs, mus.fitModel)
            dump()(newModels)
            -- local hW = 5
            -- local vectorW = func.interlace({
            --     -hW,
            --     - hW + edgeWidth,
            --     -hW + edgeWidth + sideWidth,
            --     hW - edgeWidth - sideWidth,
            --     hW - edgeWidth,
            --     hW
            -- })
            -- local vectorMW = {edgeWidth, sideWidth, (hW - edgeWidth - sideWidth) * 2, sideWidth, edgeWidth}
            -- local vectorM = {"edgeLeft", "left", "central", "right", "edgeRight"}
            -- local newModels = pipe.mapn(vectorW, vectorMW, vectorM)(function(w, mw, m)
            --     local size = makeSize(unpack(w))
            --     return {
            --         station.newModel(result.modelType.platform[m] .. "_tl.mdl", mus.fitModel(mw, segmentLength, platformHeight, size, true, true)),
            --         station.newModel(result.modelType.platform[m] .. "_br.mdl", mus.fitModel(mw, segmentLength, platformHeight, size, false, false))
            --     }
            -- end)
            
            result.models =
                pipe.new
                * result.models
                + newModels
        end,
        
        getModelsFn = function(params)
            local hW = 5
            local vectorW = func.interlace({
                -hW
                - hW + edgeWidth,
                -hW + edgeWidth + sideWidth,
                hW - edgeWidth - sideWidth,
                hW - edgeWidth,
                hW
            })
            local vectorMW = {edgeWidth, sideWidth, (hW - edgeWidth - sideWidth) * 2, sideWidth, edgeWidth}
            local vectorM = {"edgeLeft", "left", "central", "right", "edgeRight"}
            
            return
                pipe.new
                * pipe.mapn(vectorW, vectorMW, vectorM)(function(w, mw, m)
                    local size = makeSize(unpack(w))
                    return {
                        station.newModel(m .. "_tl.mdl", mus.fitModel(mw, segmentLength, platformHeight, size, true, true)),
                        station.newModel(m .. "_br.mdl", mus.fitModel(mw, segmentLength, platformHeight, size, false, false))
                    }
                end)
                * pipe.flatten()
        end
    }

end
