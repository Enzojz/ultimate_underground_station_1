local func = require "entry/func"
local coor = require "entry/coor"
local pipe = require "entry/pipe"
local general = require "entry/general"
local station = require "mus/stationlib"
local mus = require "mus"
local quat = require "entry/quaternion"
local dump = require "luadump"

local unpack = table.unpack
local ma = math
local pi = ma.pi

local segmentLength = 5
local platformHeight = 1.93
local trackWidth = 5

local function makeSize(left, right)
    return {
        lb = coor.xyz(left, -2.5, 0),
        lt = coor.xyz(left, 2.5, 0),
        rt = coor.xyz(right, 2.5, 0),
        rb = coor.xyz(right, -2.5, 0)
    }
end

local arcGen = function(p, o) return {
    l = p.l(o),
    r = p.r(-o)
} end

local mc = function(lc, rc) return func.map2(lc, rc, function(l, r) return l:avg(r) end) end

local arcProfiles = function(config, arcs)
    local refZ = config.hPlatform

    local arc = arcs[1]
    local ceil = arcGen(
        {
            l = arc(refZ)(),
            r = arc(refZ)()
        },
        -trackWidth * 0.5)
    
    local terrain = arcGen(
        {
            l = arc(refZ + 7.75)(function(l) return l + 5 end),
            r = arc(refZ + 7.75)(function(l) return l + 5 end)
        },
        -trackWidth * 0.5)
    
    local lpc, rpc, c = mus.biLatCoords(5)(ceil.l, ceil.r)
    local ltc, rtc, tc = mus.biLatCoords(5)(terrain.l, terrain.r)
    
    return {
        [1] = arc,
        count = c,
        ceil = func.with(ceil, {lc = lpc, rc = rpc, mc = mc(lpc, rpc), c = c}),
        terrain = func.with(terrain, {lc = ltc, rc = rtc, mc = mc(ltc, rtc), c = tc}),
        isTrack = true
    }
end

local buildSurface = function(fitModel, config, platformZ, tZ)
    return function(c, w, fnSize)
        local fnSize = fnSize or function(_, lc, rc) return mus.assembleSize(lc, rc) end
        return function(i, s, ...)
            local sizeS = fnSize(i, ...)
            
            return s
                and pipe.new
                / station.newModel(s .. "_tl.mdl", tZ, fitModel(w, 5, platformZ, sizeS, true, true))
                / station.newModel(s .. "_br.mdl", tZ, fitModel(w, 5, platformZ, sizeS, false, false))
                or pipe.new * {}
        end
    end
end

local il = pipe.interlace({"s", "i"})

local platform = function(config, arcs, fitModel)
    local platformZ = config.hPlatform + 0.53 --target Z
    local buildCeil = buildSurface(fitModel, config, platformZ, coor.I())
    local ceilTop = pipe.rep(2 * arcs.ceil.c - 2)(config.models.top.track.central)
        
    return pipe.new
        * pipe.mapn(
            func.seq(1, 2 * arcs.ceil.c - 2),
            ceilTop,
            il(arcs.ceil.lc), il(arcs.ceil.rc)
        )(buildCeil(arcs.ceil.c, 5))
        * pipe.flatten()
end

function data()
    return {
        availability = {
            yearFrom = 0,
            yearTo = 0,
        },
        buildMode = "SINGLE",
        cost = {
            price = 15000,
        },
        description = {
            name = _("5m Underground platform"),
            description = _("An underground platform of 5m wide"),
            icon = "ui/construction/street/underpass_entry.tga"
        },
        category = {
            categories = {"platform"},
        },
        type = "mus_platform",
        order = {
            value = 260,
        },
        metadata = {
            platform = true,
            width = 5
        },
        
        updateFn = function(result, transform, tag, slotId, addModelFn, params)
            local allArcs = arcProfiles(result.config, result.arcs[slotId])
            local newModels = platform(result.config, allArcs, mus.fitModel)

            result.models =
                pipe.new
                * result.models
                + newModels
        end,
        
        getModelsFn = function(params)
            local hW = 5
            local vectorW = func.interlace({
                -hW
                - hW + edgeWidth,
                -hW + edgeWidth + sideWidth,
                hW - edgeWidth - sideWidth,
                hW - edgeWidth,
                hW
            })
            local vectorMW = {edgeWidth, sideWidth, (hW - edgeWidth - sideWidth) * 2, sideWidth, edgeWidth}
            local vectorM = {"edgeLeft", "left", "central", "right", "edgeRight"}
            
            return
                pipe.new
                * pipe.mapn(vectorW, vectorMW, vectorM)(function(w, mw, m)
                    local size = makeSize(unpack(w))
                    return {
                        station.newModel(m .. "_tl.mdl", mus.fitModel(mw, segmentLength, platformHeight, size, true, true)),
                        station.newModel(m .. "_br.mdl", mus.fitModel(mw, segmentLength, platformHeight, size, false, false))
                    }
                end)
                * pipe.flatten()
        end
    }

end
