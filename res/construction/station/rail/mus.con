local func = require "entry/func"
local coor = require "entry/coor"
local pipe = require "entry/pipe"
local mus = require "mus"
local musm = require "mus_menu"

local dump = require "luadump"

local ma = math
local abs = ma.abs
local ceil = ma.ceil
local floor = ma.floor
local pi = ma.pi
local atan = ma.atan
local pow = ma.pow
local cos = ma.cos
local sin = ma.sin
local min = ma.min
local e = ma.exp(1)
local log = ma.log
local log10 = log(10)
local unpack = table.unpack

local depth = -12
local function params()
    return {
        {
            key = "wall",
            name = _("Wall"),
            values = {
                "ui/construction/station/rail/tiles.tga",
                "ui/construction/station/rail/tiles_classic.tga"
            },
            uiType = "ICON_BUTTON",
            defaultIndex = 0
        },
        {
            key = "floor",
            name = _("Floor Style"),
            values = {
                "ui/construction/station/rail/marble.tga",
                "ui/construction/station/rail/honeycomb.tga",
                "ui/construction/station/rail/marble_geometric.tga",
                "ui/construction/station/rail/concrete_tiles2.tga",
                "ui/construction/station/rail/asphalt.tga"
            },
            uiType = "ICON_BUTTON",
            tooltip = _("Floor Style"),
            defaultIndex = 0
        },
        {
            key = "radius",
            name = _("Radius") .. " " .. "(m)",
            values = musm.rList * pipe.map(function(r) return r > 15 and "∞" or tostring(math.floor(r * 1000)) end),
            uiType = "SLIDER",
            defaultIndex = (#musm.rList - 1) / 2
        },
        {
            key = "lPlatform",
            name = _("Platform Length") .. " " .. "(m)",
            values = func.map(musm.trackLengths, tostring),
            uiType = "SLIDER",
            defaultIndex = 5
        },
        {
            key = "hPlatform",
            name = _("Platform Height") .. " " .. "(mm)",
            values = func.map(musm.hPlatformList, tostring),
            uiType = "SLIDER",
            defaultIndex = 3
        },
        {
            key = "slope",
            name = _("Slope") .. " " .. "(‰)",
            values = func.map(musm.slopeList, tostring),
            uiType = "SLIDER",
            defaultIndex = (#musm.slopeList - 1) / 2
        }
    }
end

local offsetGen = function(meta)
    local function gen(result, base, lastPos, fst, snd, ...)
        if (fst and snd) then
            local pos = snd.pos
            local offset = base + (fst.width + snd.width) * 0.5
            
            return gen(result + {{pos, offset}}, offset, pos, snd, ...)
        else
            return result
        end
    end
    return gen(pipe.new * {}, 0, nil, {width = 0}, unpack(meta))
end

local function connectionLevel(lhs, rhs)
    local result = lhs
    * pipe.map(
        function(l) 
            return func.map(rhs, 
            function(r) 
                return {
                    distance = (l - r):length2(),
                    pt = {l, r}
                }
            end)
        end)
    * pipe.flatten()
    * pipe.sort(function(l, r) return l.distance < r.distance end)
    
    return result[1]
end

local function closestConnection(result, measure, ...)
    local rest = {...}
    if (#rest == 0) then return result end
    local r = false
    for i = 1, #rest do
        local a = rest[i]
        for j = 1, #result do
            local b = result[j].index
            r = r and r.measure and r.measure.distance < measure[a][b].distance and r or {index = a, measure = measure[a][b]}
        end
    end
    return closestConnection(result / r, measure, unpack(func.filter(rest, function(i) return i ~= r.index end)))
end

local function connectionNetwork(allConns)
    local measure = {}
    for i = 1, #allConns do
        measure[i] = {}
        for j = 1, i - 1 do
            measure[i][j] = connectionLevel(allConns[i], allConns[j])
            measure[j][i] = measure[i][j]
        end
    end

    local result = closestConnection(pipe.new / {index = 1}, measure, unpack(func.seq(2, #allConns)))
    return result * pipe.filter(pipe.select("measure")) * pipe.map(function(r) return  mus.unitLane(unpack(r.measure.pt)) end)
end

local makeConfig = function(params, transf)
    local radius = musm.rList[params.radius + 1] * 1000
    local length = min(musm.trackLengths[params.lPlatform + 1], abs(radius * pi * 1.5))
    local hPlatform = musm.hPlatformList[params.hPlatform + 1] * 0.001
    local slope = musm.slopeList[params.slope + 1] * 0.001
    
    local modelType = mus.models({platform = params.floor + 1, wall = params.wall + 1})
    
    local trans, mr, _ = coor.decomposite(transf)

    return {
        isFinalized = params.isFinalized == 1,
        fitModel = slope == 0 and mus.fitModel2D(depth + trans.z) or mus.fitModel,
        hPlatform = hPlatform,
        radius = radius,
        refZ = hPlatform + 0.53,
        slope = slope,
        models = modelType,
        depth = depth,
        length = length,
        transf = {
            pt = transf * coor.transZ(depth),
            vec = mr
        }
    } 
end

local makeLayout = function(totalTracks, ignoreFst, ignoreLst)
    local function makeLayout(nbTracks, result)
        local p = false
        local t = true
        if (nbTracks == 0) then
            local result = ignoreLst and result or (result[#result] and (result / p) or result)
            return result
        elseif (nbTracks == totalTracks and ignoreFst) then
            return makeLayout(nbTracks - 1, result / t )
        elseif (nbTracks == totalTracks and not ignoreFst) then
            return makeLayout(nbTracks - 1, result / p / t)
        elseif (nbTracks == 1 and ignoreLst) then
            return makeLayout(nbTracks - 1, ((not result) or result[#result]) and (result / p / t) or (result / t))
        elseif (nbTracks == 1 and not ignoreLst) then
            return makeLayout(nbTracks - 1, result / t / p)
        elseif (result[#result] == t) then
            return makeLayout(nbTracks - 2, result / t / p / t)
        else
            return makeLayout(nbTracks - 1, result / t)
        end
    end
    return makeLayout(totalTracks, pipe.new)
end

local createTemplateFn = function(params)
    local radius = musm.rList[params.radius + 1] * 1000
    local length = min(musm.trackLengths[params.lPlatform + 1], abs(radius * pi * 1.5))

    local nbTracks = musm.trackNumberList[params.trackNb + 1]
    local layout = makeLayout(nbTracks, params.platformLeft == 0, params.platformRight == 0)
    local midPos = ceil(#layout / 2)
    local nSeg = length / 5
    local stair = floor(nSeg / 4)
    local result = {}
    for i, t in ipairs(layout) do
        if t then
            result[(i - midPos >= 0 and i or 1000 + i) - midPos] = "station/rail/mus_track.module"
        else
            local slot = (i - midPos >= 0 and i or 1000 + i) + 1000 - midPos
            result[slot] = "station/rail/mus_platform_10m.module"
            result[slot + 2000 + stair * 100000] = "station/rail/mus_platform_upstair.module"
            result[slot + 2000 + (stair + 1) * 100000] = "station/rail/mus_platform_upstair.module"
        end
    end
    
    return result
end

local upgradeFn = function(params)
    return {}
end

local updateFn = function(params)
    if #func.keys(params.modules) == 0 then
        return {
            edgeLists = {},
            models = {{
                id = "asset/icon/marker_exclamation.mdl",
                transf = coor.I(),
            }},
            terrainAlignmentLists = {{type = "EQUAL", faces = {}}}
        }
    end


    local result = {
        group = {},
        allArcs = {},
        slots = pipe.new * {},
        invoke = {{},{}},
        models = pipe.new * {},
        terrainAlignmentLists = {},
        edgeLists = pipe.new * {},
        colliders = {},
        groundFaces = {},
        terminalGroups = {},
        stations = {},
        dependentSlots = {},
        slotConfig = {},
        occupied = {{}, {}, {}, {}},
        terminalInfo = {},
        cost = 0
    }
    
    for slotId, m in pairs(params.modules) do
        local info = mus.slotInfo(slotId)
        if (info.pos.z < 9) then
            if (not result.group[info.pos.z]) then
                result.group[info.pos.z] =
                {
                    allPos = pipe.new * {},
                    pos2Slot = {},
                    connectors = {},
                    modules = {},
                    arcs = {},
                    terminalInfo = {}
                }

            end
            if (params.modules[slotId].params and not result.group[info.pos.z].config) then
                result.group[info.pos.z].config = makeConfig(params.modules[slotId].params, params.modules[slotId].transf)
            end
        end
    end

    for _, g in pairs(result.group) do
        if (not g.config) then
            g.config = makeConfig(params, coor.I())
        end
    end

    for slotId, m in pairs(params.modules) do
        local info = mus.slotInfo(slotId)
        if info.typeId < 2 then
            local gr = result.group[info.pos.z]
            local pos = info.pos.x
            gr.allPos[#gr.allPos + 1] = pos
            gr.pos2Slot[pos] = slotId
            gr.modules[pos] = func.with(m,
                {
                    slotId = slotId,
                    metadata = func.with(m.metadata, {pos = pos})
                }
        )
        end
    end
    
    for n, g in pairs(result.group) do
        g.allPos = g.allPos * pipe.sort()
        local config = g.config
        local posMin = func.min(g.allPos)
        local posMax = func.max(g.allPos)
        
        local offsets = pipe.new
            * func.seq(posMin > 0 and -1 or (posMin - 1), posMax + 1)
            * pipe.map(function(pos)
                return g.modules[pos] and g.modules[pos].metadata or {pos = pos, width = 5}
            end)
            * offsetGen
        
        local reOffset = func.filter(offsets, function(o) return o[1] == 0 end)[1][2]
        offsets = offsets * pipe.map(function(o) return {o[1], o[2] - reOffset} end)

        local mrr = config.radius - offsets[config.radius < 0 and 1 or #offsets][2]

        local refLength = (config.radius / mrr) * config.length
        config.arcPacker = mus.arcPacker(refLength, config.slope, config.radius)
        
        local entityOffsets = offsets * pipe.fold(pipe.new * {}, function(r, o) return func.contains(g.allPos, o[1]) and r / o[2] or r end)
        
        for i, pos in ipairs(g.allPos) do
            g.arcs[pos] = config.arcPacker(config.radius - entityOffsets[i], coor.xyz(config.radius, 0, 0))
        end
        local slots = offsets
            * pipe.map(function(ph)
                local pos, offset = unpack(ph)
                return {
                    {
                        id = n * 10000 + (pos < 0 and (pos + 1000) or pos),
                        transf = coor.transX(offset) * g.config.transf.pt,
                        type = "mus_track",
                        spacing = {2.5, 2.5, 5, 5}
                    },
                    {
                        id = n * 10000 + (pos < 0 and (pos + 1000 + 1000) or (pos + 1000)),
                        transf = coor.transX(offset) * g.config.transf.pt,
                        type = "mus_platform",
                        spacing = {2.5, 2.5, 5, 5}
                    }
                }
            end)
            * pipe.flatten()
        result.slots = result.slots + slots
    end
    
    result.terminateConstructionHook = function()
        for _, f in ipairs(result.invoke[1]) do f() end
        for _, f in ipairs(result.invoke[2]) do f() end
        
        local connectors = pipe.new * {}
        
        for _, g in pairs(result.group) do
            local modules = g.modules
            local posSeq = pipe.new * func.seq(func.min(g.allPos), func.max(g.allPos))
            local initPos = modules[0] and modules[0].metadata.platform and 1 or 0
            local orderedPos = posSeq * pipe.filter(function(pos) return pos >= initPos end) + posSeq * pipe.filter(function(pos) return pos < initPos end) * pipe.rev()
            for _, pos in ipairs(orderedPos) do
                local m = modules[pos]
                if m then
                    if m.metadata.track then
                        if (modules[pos - 1] and modules[pos - 1].metadata.platform) then
                            local node = g.terminalInfo[pos] + 1
                            result.terminalGroups[#result.terminalGroups + 1] = {
                                callbacks = {},
                                terminals = func.seqMap(g.terminalInfo[pos - 1][2], function(t) return {t, 0} end),
                                vehicleNodeOverride = node,
                                vehicleNodeOverrideList = {node},
                                vehicleNodeOverrideListCenter = {node + 3}
                            }
                        end
                        if (modules[pos + 1] and modules[pos + 1].metadata.platform) then
                            local node = g.terminalInfo[pos] + 7
                            result.terminalGroups[#result.terminalGroups + 1] = {
                                callbacks = {},
                                terminals = func.seqMap(g.terminalInfo[pos + 1][1], function(t) return {t, 0} end),
                                vehicleNodeOverride = node,
                                vehicleNodeOverrideList = {node},
                                vehicleNodeOverrideListCenter = {node + 3}
                            }
                        end
                    end
                    if m.metadata.platform then
                        if (g.connectors[pos]) then
                            local lanes = pipe.new * {
                                #g.connectors[pos].up > 1 and func.interlace(g.connectors[pos].up) or {},
                                #g.connectors[pos].down > 1 and func.interlace(g.connectors[pos].down) or {}
                            }
                            * pipe.flatten()
                            * pipe.map(function(c) return mus.unitLane(unpack(c)) end)
                            result.models = result.models + lanes
                        end
                    end
                end
            end
            
            local allConnectors = pipe.new
                * g.allPos
                * pipe.filter(function(pos) return g.modules[pos].metadata.platform end)
                * pipe.map(function(pos) return g.connectors[pos] end)
            
            result.models = result.models
                + mus.linkConnectors(allConnectors * pipe.map(pipe.select("up")))
                + mus.linkConnectors(allConnectors * pipe.map(pipe.select("down")))
            
            table.insert(connectors, (allConnectors * pipe.map(pipe.select("up")) + allConnectors * pipe.map(pipe.select("down"))) * pipe.flatten())
        end
        
        -- local conn, ctable = generateConnectionNetwork(pipe.new * {}, pipe.new * {}, unpack(connectors))
        -- local conn = conn * pipe.map(function(c) return mus.unitLane(c[1], c[2]) end)
        local conn = connectionNetwork(connectors)
        result.models = result.models + conn
    end
    
    return result
end

function data()
    local constructionTemplates =
        {
            {
                constructionType = "RAIL_STATION",
                type = "DYNAMIC",
                availability = {
                    yearFrom = 0,
                    yearTo = 0
                },
                description = {
                    name = _("Underground Station"),
                    description = _("An underground level for a station, width adjustable platform width and radius."),
                    icon = "ui/construction/station/rail/mus.tga"
                },
                data = {
                    params = {
                        {
                            key = "trackNb",
                            name = _("Track numbers"),
                            values = func.map(musm.trackNumberList, tostring),
                            uiType = "SLIDER",
                            defaultIndex = 1
                        },
                        {
                            key = "platformLeft",
                            name = _("Platform on the left"),
                            uiType = "CHECKBOX",
                            values = {"0", "1"},
                        },
                        {
                            key = "platformRight",
                            name = _("Platform on the right"),
                            uiType = "CHECKBOX",
                            values = {"0", "1"},
                        },
                        {
                            key = "isFinalized",
                            name = _("Force to use"),
                            uiType = "CHECKBOX",
                            values = {"0", "1"},
                            defaultIndex = 0
                        },
                    }
                },
            }
        }

    return {
        type = "RAIL_STATION",
        description = {
            name = _("Underground Station"),
            description = _("An underground level for a station, width adjustable platform width and radius.")
        },
        availability = {
            yearFrom = 0,
            yearTo = 0
        },
        order = 1000,
        constructionTemplates = constructionTemplates,
        createTemplateFn = createTemplateFn,
        params = params(),
        upgradeFn = upgradeFn,
        updateFn = updateFn
    }
end
