local paramsutil = require "paramsutil"
local func = require "entry/func"
local coor = require "entry/coor"
local general = require "entry/general"
local line = require "mus/coorline"
local trackEdge = require "mus/trackedge"
local quat = require "entry/quaternion"
local pipe = require "entry/pipe"
local mus = require "mus"
local musm = require "mus_menu"

local dump = require "luadump"

-- local musm = require "mus_menu"
local ma = math
local abs = ma.abs
local ceil = ma.ceil
local floor = ma.floor
local pi = ma.pi
local atan = ma.atan
local pow = ma.pow
local cos = ma.cos
local sin = ma.sin
local min = ma.min
local e = ma.exp(1)
local log = ma.log
local log10 = log(10)
local unpack = table.unpack

local linkConnectors = function(allConnectors)
    return
        allConnectors
        * pipe.interlace()
        * pipe.map(function(conn)
            local recordL = {}
            local recordR = {}
            if (#conn[1] == 0 and #conn[2] == 0) then return {} end
            
            for i, l in ipairs(conn[1]) do
                for j, r in ipairs(conn[2]) do
                    local vec = l - r
                    local dist = vec:length2()
                    recordL[i] = recordL[i] and recordL[i].dist < dist and recordL[i] or {dist = dist, vec = vec, i = i, j = j, l = l, r = r}
                    recordR[j] = recordR[j] and recordR[j].dist < dist and recordR[j] or {dist = dist, vec = vec, i = i, j = j, l = l, r = r}
                end
            end
            
            return #recordL == 0 and #recordR == 0 and {} or (pipe.new + recordL + recordR)
                * pipe.sort(function(l, r) return l.i < r.i or (l.i == r.i and l.j < r.j) end)
                * pipe.fold(pipe.new * {}, function(result, e)
                    if #result > 0 then
                        local lastElement = result[#result]
                        return (lastElement.i == e.i and lastElement.j == e.j) and result or (result / e)
                    else
                        return result / e
                    end
                end)
                * pipe.map(function(e) return mus.unitLane(e.l, e.r) end)
        end)
        * pipe.flatten()
end

local function params()
    return
        pipe.new
        +
        {
            {
                key = "wall",
                name = _("Wall"),
                values = {_("Tiles 1"), _("Tiles 2")},
                defaultIndex = 0
            },
            {
                key = "floor",
                name = _("Floor Style"),
                values = {_("Marble 1"), _("Honeycomb"), _("Marble 2"), _("Concrete"), _("Asphalt")},
                defaultIndex = 0
            }
        }
        +
        {
            {
                key = "sign",
                name = "",
                values = {"+", "-"},
                defaultIndex = 0
            },
            {
                key = "radius",
                name = _("Radius") .. " " .. "(m)",
                values = pipe.from("∞") + func.map(func.range(musm.rList, 2, #musm.rList), function(r) return tostring(math.floor(r * 1000 + 0.5)) end),
                defaultIndex = 0
            },
            {
                key = "length",
                name = _("Platform Length") .. " " .. "(m)",
                values = func.map(musm.trackLengths, tostring),
                defaultIndex = 5
            }
        }
        +
        {
            {
                key = "hPlatform",
                name = _("Platform Height") .. " " .. "(mm)",
                values = func.map(musm.hPlatformList, tostring),
                defaultIndex = 3
            }
        } +
        {
            {
                key = "slopeSign",
                name = "",
                values = {"+", "-"},
                defaultIndex = 0
            },
            {
                key = "slope",
                name = _("Slope") .. " " .. "(‰)",
                values = func.map(musm.slopeList, tostring),
                defaultIndex = 0
            }
        }
        + {
            {
                key = "altitude",
                name = _("Depth Adjustment") .. " " .. "(m)",
                values = func.seqMap({-5, 5}, tostring),
                defaultIndex = 5
            }
        }
end

local offsetGen = function(meta)
    local function gen(result, base, fst, snd, ...)
        if (fst and snd) then
            local offset = base + (fst.width + snd.width) * 0.5
            
            local data = snd.track and {offset} or
                {
                    offset,
                    base + fst.width * 0.5,
                    base + fst.width * 0.5 + snd.width
                }
            return gen(result / data, offset, snd, ...)
        else
            return result
        end
    end
    return gen(pipe.new * {}, 0, {width = 0}, unpack(meta))
end

function data()
    local constructionTemplates =
        {
            {
                constructionType = "RAIL_STATION",
                type = "DYNAMIC",
                availability = {
                    yearFrom = 0,
                    yearTo = 0
                },
                description = {
                    name = _("Underground Station"),
                    description = _("An underground level for a station, width adjustable platform width and radius."),
                    icon = "ui/construction/station/rail/mus.tga"
                },
                data = {
                    params = {}
                },
            }
        }
    
    local createTemplateFn = function(params)
        local result = {
            [1001] = "station/rail/mus_platform_10m.module",
            [2] = "station/rail/mus_track.module",
        }
        
        return result
    end
    
    local upgradeFn = function(params)
        end
    
    local updateFn = function(params)
        if #func.keys(params.modules) == 0 then
            return {
                edgeLists = {},
                models = {{
                    id = "asset/icon/marker_exclamation.mdl",
                    transf = coor.I(),
                }},
                terrainAlignmentLists = {{type = "EQUAL", faces = {}}}
            }
        end
        
        local result = {}
        
        local radius = musm.rList[params.radius + 1] * 1000 * (params.sign == 0 and 1 or -1)
        local length = min(musm.trackLengths[params.length + 1], abs(radius * pi * 1.5))
        local hPlatform = musm.hPlatformList[params.hPlatform + 1] * 0.001
        local slope = musm.slopeList[params.slope + 1] * 0.001 * (params.slopeSign == 0 and 1 or -1)
        
        local arcPacker = mus.arcPacker(length, slope, radius)
        
        result.modelType = mus.models({platform = params.floor + 1, wall = params.wall + 1})
        
        result.arcs = {}
        result.slotId2Rank = {}
        local modules = {}
        local allPos = {}
        local pos2Slot = {}
        result.connectors = {}
        
        for slotId, m in pairs(params.modules) do
            local info = mus.slotInfo(slotId)
            if info.typeId < 2 then
                table.insert(allPos, info.pos.x)
                pos2Slot[info.pos.x] = slotId
            end
        end
        allPos = pipe.new * allPos * pipe.sort()
        
        for rank = 1, #allPos do
            local pos = allPos[rank]
            local slotId = pos2Slot[pos]
            result.slotId2Rank[slotId] = rank
            modules[rank] = func.with(
                params.modules[slotId], {
                    slotId = slotId,
                    pos = pos,
                    rank = rank
                }
        )
        end
        
        local minPositive = allPos * pipe.filter(function(p) return p > 0 end) * pipe.min()
        local offsets = pipe.new * modules * pipe.map(pipe.select("metadata")) * offsetGen
        local reOffset = offsets[result.slotId2Rank[pos2Slot[minPositive]] or 1][1]
        offsets = offsets * pipe.map(pipe.map(pipe.plus(-reOffset)))
        result.arcs = offsets * pipe.map(pipe.map(function(of) return arcPacker(radius - of, coor.xyz(radius, 0, 0)) end))
        
        
        
        result.allArcs = {}
        result.config = {
            hPlatform = hPlatform,
            refZ = hPlatform,
            slope = slope,
            models = result.modelType,
        }
        result.slots = {}
        result.invoke = {}
        
        local rankMax = func.max(allPos)
        local rankMin = func.min(allPos)
        
        result.slots = pipe.new * func.map2(modules, offsets,
            function(m, o)
                return {
                    id = m.slotId,
                    transf = coor.transX(o[1]),
                    type = m.metadata.type,
                    spacing = {m.metadata.width * 0.5, m.metadata.width * 0.5, 5, 5}
                }
            end
        )
        result.slots = result.slots + {
            {
                id = rankMax + 1,
                transf = coor.transX(offsets[#offsets][1] + result.slots[#result.slots].spacing[1] + 2.5),
                type = "mus_track",
                spacing = {2.5, 2.5, 5, 5}
            },
            {
                id = rankMax + 1 + 1000,
                transf = coor.transX(offsets[#offsets][1] + result.slots[#result.slots].spacing[1] + 5),
                type = "mus_platform",
                spacing = {5, 5, 5, 5}
            },
            {
                id = (rankMin - 1 < 0) and (rankMin - 1 + 1000) or (rankMin - 1),
                transf = coor.transX(offsets[1][1] - result.slots[1].spacing[1] - 2.5),
                type = "mus_track",
                spacing = {2.5, 2.5, 5, 5}
            },
            {
                id = (rankMin - 1 < 0) and (rankMin - 1 + 1000 + 1000) or (rankMin - 1 + 1000),
                transf = coor.transX(offsets[1][1] - result.slots[1].spacing[1] - 5),
                type = "mus_platform",
                spacing = {5, 5, 5, 5}
            }
        }
        
        result.newSlots = pipe.new * {}
        
        result.models = pipe.new * {}
        
        result.colliders = {}
        result.terrainAlignmentLists = {{type = "EQUAL", faces = {}}}
        result.groundFaces = {}
        result.terminalGroups = {}
        result.stations = {}
        result.dependentSlots = {}
        result.edgeLists = {}
        result.slotConfig = {}
        
        result.occupied = {{}, {}, {}, {}}
        result.terminalInfo = {}
        result.cost = 0
        result.terminateConstructionHook = function()
                
                for _, f in ipairs(result.invoke) do f() end
                
                for rank, m in pairs(modules) do
                    if m.metadata.track then
                        if (modules[rank - 1] and modules[rank - 1].metadata.platform) then
                            local node = (rank - 1) * 12 + 1
                            result.terminalGroups[#result.terminalGroups + 1] = {
                                callbacks = {},
                                terminals = func.seqMap(result.terminalInfo[rank - 1][2], function(t) return {t, 0} end),
                                vehicleNodeOverride = node,
                                vehicleNodeOverrideList = {node},
                                vehicleNodeOverrideListCenter = {node + 3}
                            }
                        end
                        if (modules[rank + 1] and modules[rank + 1].metadata.platform) then
                            local node = (rank - 1) * 12 + 7
                            result.terminalGroups[#result.terminalGroups + 1] = {
                                callbacks = {},
                                terminals = func.seqMap(result.terminalInfo[rank + 1][1], function(t) return {t, 0} end),
                                vehicleNodeOverride = node,
                                vehicleNodeOverrideList = {node},
                                vehicleNodeOverrideListCenter = {node + 3}
                            }
                        end
                    end
                    
                    if m.metadata.platform then
                        if (result.connectors[rank]) then
                            local lanes = pipe.new * {
                                #result.connectors[rank].up > 1 and func.interlace(result.connectors[rank].up) or {},
                                #result.connectors[rank].down > 1 and func.interlace(result.connectors[rank].down) or {}
                            }
                            * pipe.flatten()
                            * pipe.map(function(c) return mus.unitLane(unpack(c)) end)
                            
                            result.models = result.models + lanes
                        end
                    end
                end
                
                local allConnectors = pipe.new
                    * func.values(modules)
                    * pipe.filter(function(m) return m.metadata.platform end)
                    * pipe.map(function(m) return result.connectors[m.rank] end)
                
                result.models = result.models
                    + linkConnectors(allConnectors * pipe.map(pipe.select("up")))
                    + linkConnectors(allConnectors * pipe.map(pipe.select("down")))
        end
        
        return result
    end
    
    return {
        type = "RAIL_STATION",
        description = {
            name = _("Underground Station"),
            description = _("An underground level for a station, width adjustable platform width and radius.")
        },
        availability = {
            yearFrom = 0,
            yearTo = 0
        },
        order = 1000,
        constructionTemplates = constructionTemplates,
        createTemplateFn = createTemplateFn,
        params = params(),
        upgradeFn = upgradeFn,
        updateFn = updateFn
    }
end
