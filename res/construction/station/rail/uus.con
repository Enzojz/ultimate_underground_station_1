local paramsutil = require "paramsutil"
local func = require "uus/func"
local coor = require "uus/coor"
local line = require "uus/coorline"
local trackEdge = require "uus/trackedge"
local station = require "uus/stationlib"
local quat = require "uus/quaternion"
local pipe = require "uus/pipe"
local uus = require "uus"
local uusm = require "uus_menu"

local ma = math
local abs = ma.abs
local ceil = ma.ceil
local floor = ma.floor
local pi = ma.pi
local atan = ma.atan
local pow = ma.pow
local cos = ma.cos
local sin = ma.sin
local min = ma.min
local e = ma.exp(1)
local log = ma.log
local log10 = log(10)

local prefixM = "uus/1990/"
local models = uus.models(prefixM)

local function params()
    local sp = "·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·\n"
    return
        pipe.new
        + uusm.trackType
        +
        {
            {
                key = "nbTracks",
                name = _("Number of tracks"),
                values = func.map(uusm.trackNumberList, tostring),
            },
            {
                key = "nbTransitTracks",
                name = sp .. "\n" .. _("Transit Tracks"),
                values = func.map({0, 1, 2, 3, 4}, tostring),
                defaultIndex = 0
            },
            {
                key = "posTransitTracks",
                name = _("Position"),
                values = {_("Left"), _("Centre"), _("Sides"), _("Right")},
                defaultIndex = 1
            },
            {
                key = "sign",
                name = sp,
                values = {"+", "-"},
                defaultIndex = 0
            },
            {
                key = "radius",
                name = _("Radius") .. " " .. "(m)",
                values = pipe.from("∞") + func.map(func.range(uusm.rList, 2, #uusm.rList), function(r) return tostring(math.floor(r * 1000 + 0.5)) end),
                defaultIndex = 0
            },
            {
                key = "length",
                name = sp .. "\n" .. _("Platform") .. "\n\n" .. _("Length") .. " " .. "(m)",
                values = func.map(uusm.trackLengths, tostring),
                defaultIndex = 5
            }
        }
        + uusm.exclu("hasMiddlePlatform", "convAngle")(uusm.platform)
        + uusm.var
        + uusm.slope
        + uusm.alt
end

local buildStation = function(totalTracks, arcPacker, config, ignoreFst, ignoreLst)
    local pW = config.wPlatform
    local tW = config.wTrack
    local bandWidth = 0.8
    local fitModel = slope == 0 and uus.fitModel2D or uus.fitModel
    
    local ptList = uus.preBuild(totalTracks, config.nbTransitTracks, config.posTransitTracks, ignoreFst, ignoreLst)(totalTracks, pipe.new)
    local ptListI = ptList * pipe.zip(func.seq(1, #ptList), {"t", "i"})
    local refList = ptListI
        * pipe.filter(function(x) return config.varRefIsTrack and x.t or not x.t end)
        * pipe.map(pipe.select("i"))
        * pipe.sort(function(x, y) return x < y end)
    local middlePos =
        config.varRefPos < 0 and refList[1]
        or config.varRefPos > 0 and refList[#refList]
        or #refList % 2 == 1 and refList[(#refList + 1) * 0.5] or refList[#refList * 0.5]
    
    local leftGroup = ptListI * pipe.filter(function(p) return p.i < middlePos end) * pipe.rev()
    local middleGroup = ptListI * pipe.filter(function(p) return p.i == middlePos end)
    local rightGroup = ptListI * pipe.filter(function(p) return p.i > middlePos end)
    local platformArcGen = uus.platformArcGen(tW, pW)(arcPacker)
    
    local lengthFn = function(posPct) return 1 - (1 - config.lExtPlatform) * uus.varFn(config.lExtPlatform)[config.varModelLength](posPct) end

    local function generateArcs(init, initDr, initX)
        local function arcGen(result, r, o, isRight)
            return isRight
                and function(t, ...)
                    if t == nil then
                        return result * pipe.sort(function(l, r) return l.i < r.i end) * pipe.map(pipe.select("a"))
                    else
                        local posPct = abs(t.i - middlePos) / (#rightGroup)
                        local isVar = posPct > config.varNbUnaffected
                        local lengthPct = isVar and lengthFn(posPct) or 1
                        local offsetPct = isVar and -posPct * config.yOffsetPlatform or 0
                        if t.t then
                            return arcGen(result / {i = t.i, a = {arcPacker(r - tW, o, isVar and lengthPct or 1, offsetPct)}},
                                r - tW, o, true)(...)
                        else
                            return arcGen(result / {
                                i = t.i,
                                a = {
                                    arcPacker(r - (0.5 * tW), o, lengthPct, offsetPct),
                                    arcPacker(r - (0.5 * tW + pW), o, lengthPct, offsetPct)
                                }},
                            r - pW, o, true)(...)
                        end
                    end
                end
                or function(t, ...)
                    if t == nil then
                        return arcGen(result, initDr[#initDr], initX[#initX], true)(table.unpack(rightGroup))
                    else
                        local posPct = abs(t.i - middlePos) / (#leftGroup)
                        local isVar = posPct > config.varNbUnaffected
                        local lengthPct = isVar and lengthFn(posPct) or 1
                        local offsetPct = isVar and posPct * config.yOffsetPlatform or 0
                        if t.t then
                            return arcGen(result / {i = t.i, a = {arcPacker(r + tW, o, lengthPct, offsetPct)}},
                                r + tW, o)(...)
                        else
                            return arcGen(result / {
                                i = t.i,
                                a = {
                                    arcPacker(r + (0.5 * tW + pW), o, lengthPct, offsetPct),
                                    arcPacker(r + (0.5 * tW), o, lengthPct, offsetPct)
                                }},
                            r + pW, o)(...)
                        end
                    end
                end
        end
        local rs = arcGen(pipe.new / init, initDr[1], initX[1])(table.unpack(leftGroup))
        return rs
    end
    
    local allArcs = pipe.exec * function()
        local o = coor.xyz(config.r, 0, 0)
        
        if table.unpack(middleGroup).t then
            return generateArcs(
                {
                    i = middlePos,
                    a = {arcPacker(config.r, o)}
                },
                {config.r}, {o}
        ) else
            local isVar = config.varNbUnaffected == 0
            if (not isVar) then
                return generateArcs(
                    {
                        i = middlePos,
                        a = {
                            arcPacker(config.r + 0.5 * pW, o),
                            arcPacker(config.r - 0.5 * pW, o)
                        }
                    },
                    {
                        config.r - (-0.5 * pW + 0.5 * tW),
                        config.r - (0.5 * pW - 0.5 * tW)
                    }, {o}
            )
            else
                local rR, oR, a = platformArcGen(config.r + 0.5 * pW, o, 1, 0, pW, true)
                return generateArcs(
                    {
                        i = middlePos,
                        a = a
                    },
                    {
                        config.r - (0.5 * tW),
                        rR
                    }, {o, oR}
            )
            end
        end
    end
    * function(arcs)
        local minLength = arcs 
            * pipe.filter(function(a) return #a == 1 end) 
            * pipe.map(function(a) return a[1]()()()() * function(l) return l[1]:length() + l[2]:length() end end) 
            * pipe.min()
        return arcs * pipe.map(pipe.map(function(a) return a(minLength) end))

    end
    * uus.allArcs(config)
    
    local arcCoords = allArcs * pipe.filter(function(a) return a.isPlatform end)
    

    local build = uus.build(config, fitModel)

    return build(pipe.new, pipe.new, pipe.new, pipe.new, pipe.new, pipe.new, uus.trackGrouping(pipe.new, table.unpack(allArcs)))
end

local function updateFn()
    return uus.safeBuild(params, function(params)
        local buildingList, buildingParamsList = require("uus_building")("uus/1990/")
        local trackType = uusm.trackList[params.trackType + 1]
        local trackWidth = uusm.trackWidthList[params.trackType + 1]
        local catenary = params.catenary == 1
        local trackBuilder = trackEdge.builder(catenary, trackType)
        local hPlatform = uusm.hPlatformList[params.hPlatform + 1] * 0.001
        local wPlatform = uusm.wPlatformList[params.wPlatform + 1]
        local roofLength = uusm.roofLengthList[params.roofLength + 1] * 0.01
        
        local nbTracks = uusm.trackNumberList[params.nbTracks + 1]
        local radius = (uusm.rList[params.radius + 1] * 1000) * (params.sign == 0 and 1 or -1)
        local slope = uusm.slopeList[params.slope + 1] * 0.001 * (params.slopeSign == 0 and 1 or -1)
        
        local length = min(uusm.trackLengths[params.length + 1], abs(radius * pi * 1.5))
        
        local edge, mockEdge, terminals, terminalsGroup, models, terrain =
            buildStation(nbTracks,
                uus.arcPacker(length, slope, radius),
                {
                    nbTransitTracks = params.nbTransitTracks,
                    posTransitTracks = params.posTransitTracks - 2,
                    r = radius,
                    hPlatform = hPlatform,
                    wPlatform = wPlatform,
                    lExtPlatform = 1, -- uusm.extLengthList[params.lExtPlatform + 1] * 0.01,
                    yOffsetPlatform = 0, --uusm.yOffsetList[params.yOffsetPlatform + 1] * (params.yOffsetPlatformSign == 0 and 0.01 or -0.01),
                    varRefPos = -1, --params.varRefPos - 1,
                    varRefIsTrack = true, -- params.varRefType == 0,
                    varNbUnaffected = 0,-- uusm.varUnaffectedList[params.varNbUnaffected + 1] * 0.01,
                    varModelLength = 1, --params.varModelLength + 1,
                    wTrack = trackWidth,
                    roofLength = roofLength,
                    slope = slope,
                    models = models
                },
                params.hasLeftPlatform == 0,
                params.hasRightPlatform == 0
        )
        local coffset = coor.xyz(-4.3, 0, hPlatform + 0.53)

        local result = 
            pipe.new
            * {
                edgeLists = pipe.new / (pipe.new * {edge * station.mergeEdges} * station.prepareEdges * trackBuilder.tunnel("railroad_old.lua")),
                models = terminals + models,
                terminalGroups = terminalsGroup,
                terrainAlignmentLists = station.mergePoly(table.unpack(terrain))()
            }
        return result
    end)
end

function data()
    return {
        type = "RAIL_STATION",
        description = {
            name = _("Generic Station"),
            description = _("Station that platform and track parameters can be fine-tuned, with single reference radius.")
        },
        availability = {
            yearFrom = 1850,
            yearTo = 0,
        },
        order = 5011,
        params = params(),
        updateFn = updateFn()
    }
end
