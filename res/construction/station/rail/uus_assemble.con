local paramsutil = require "paramsutil"
local func = require "uus/func"
local coor = require "uus/coor"
local line = require "uus/coorline"
local trackEdge = require "uus/trackedge"
local station = require "uus/stationlib"
local quat = require "uus/quaternion"
local pipe = require "uus/pipe"
local uus = require "uus"
local uusm = require "uus_menu"
local ma = math

local abs = ma.abs
local ceil = ma.ceil
local floor = ma.floor
local pi = ma.pi
local atan = ma.atan
local pow = ma.pow
local cos = ma.cos
local sin = ma.sin
local min = ma.min
local e = ma.exp(1)
local log = ma.log
local log10 = log(10)
local unpack = table.unpack

local function params()
    return
        {
            {
                key = "mode",
                name = _("Function"),
                values = {_("Keep"), _("Disassemble")},
                defaultIndex = 0
            },
        }
end

local pure = function(pa)
    local params = {}
    for key, value in pairs(pa) do
        if (key ~= "seed") then
            params[key] = value
        end
    end
    return params
end

local function dissassemble(params)
    local pa = pipe.new
        * game.interface.getEntities({pos = {0, 0}, radius = 900000}, {type = "CONSTRUCTION", includeData = true})
        * pipe.values()
        * pipe.filter(function(data) return data.params.seed == params.seed end)
    assert(#pa == 1)
    local params = pa[1].params
    local player = game.interface.getPlayer()
    func.forEach(params.children, function(data)
        local id = game.interface.buildConstruction(
            data.fileName,
            func.with(pure(data.params), {state = params.state}),
            data.transf
        )
        game.interface.setPlayer(id, player)
        game.interface.setName(id, data.name)
    end)
    game.interface.upgradeConstruction(
        pa[1].id,
        params.major.fileName,
        func.with(pure(params.major.params), {state = params.state})
    )
    return {models = {}}
end

local ptToSetDistance = function(pt)
    return function(pts, i)
        local distances = pipe.new * pts * pipe.map(function(p) return {pt = p, distance = (p - pt):length()} end) * pipe.sort(function(l, r) return l.distance < r.distance end)
        return {
            pt = pt,
            set = pts,
            avg = func.fold(distances, 0, function(r, d) return r + d.distance end) / #distances,
            min = distances[1].distance,
            result = distances,
            order = i
        }
    end
end

local function generateConnectionNetwork(result, current, ...)
    local allRest = pipe.new * {...}
    local current = pipe.new * current
    
    if (#allRest == 0) then return result end
    if (#current == 0) then return generateConnectionNetwork(result, ...) end
    
    local x = current
        * pipe.map(function(pt) return func.mapi(allRest, ptToSetDistance(pt)) end)
        * pipe.flatten()
        * pipe.sort(function(l, r) return l.min < r.min end)
    
    local shortestPair = x[1]
    local rest = allRest * pipe.mapi(function(pts, i) return i ~= shortestPair.order and pts or false end) * pipe.filter(pipe.noop())
    
    local current = current + shortestPair.set
    
    local avgResultIndex = ceil(#shortestPair.result * 0.5)
    
    local result = result
        / {shortestPair.pt, shortestPair.result[1].pt}
        / (avgResultIndex > 1 and {shortestPair.pt, shortestPair.result[avgResultIndex].pt} or #shortestPair.result > 1 and {shortestPair.pt, shortestPair.result[2].pt} or nil)
    
    return generateConnectionNetwork(result, current, unpack(rest))
end

local updateFn = function(params)
    if (params.mode == 1) then return dissassemble(params) end
    local result = game.config.construction[params.major.fileName](func.with(params.major.params, {state = params.state}))
    local children = func.map(params.children, function(data)
        game.interface.bulldoze(data.id)
        return pipe.new
            * game.config.construction[data.fileName](func.with(data.params, {state = params.state}))
            * station.setTransform(data.m)
    end)
    
    local allConn = pipe.new * children / result * pipe.map(pipe.select("connectors"))
    local conn = generateConnectionNetwork(pipe.new, unpack(allConn))
        * pipe.map(function(c)
            return station.newModel("uus/standard_lane.mdl", uus.mRot(c[2] - c[1]), coor.trans(c[1]))
        end)
    
    local entryConn = pipe.new 
    * params.entries
    * pipe.map(function(data)
            game.interface.bulldoze(data.id)
            local result = pipe.new
                * game.config.construction[data.fileName](func.with(data.params, {state = params.state}))
                * station.setTransform(data.m)
            local targets = func.map(result.connectors, function(pt)
                return allConn
                    * pipe.flatten()
                    * pipe.map(function(p) return {
                        pt = coor.o + p, 
                        distance = (p - pt):length(),
                        conn = station.newModel("uus/standard_lane.mdl", uus.mRot(pt - p), coor.trans(p))
                    } end)
                    * pipe.min(function(l, r) return l.distance < r.distance end)
            end)

            return (targets[1].pt - targets[2].pt):length() > 0.5
                and {func.map(targets, pipe.select("conn")), result}
                or (targets[1].distance < targets[2].distance)
                and {
                    {targets[1].conn},
                    pipe.new
                    * game.config.construction[data.fileName](func.with(data.params, {state = params.state, isLeftOpen = true, isRightOpen = false}))
                    * station.setTransform(data.m)
                }
                or {
                    {targets[2].conn},
                    pipe.new
                    * game.config.construction[data.fileName](func.with(data.params, {state = params.state, isLeftOpen = false, isRightOpen = true}))
                    * station.setTransform(data.m)
                }
        end
    )

    local entryResults = entryConn * pipe.map(pipe.select(2))
    local entryConns = entryConn
        * pipe.map(pipe.select(1))
        * pipe.flatten()
        * dump()
    
    local newResult = station.mergeResults(result, table.unpack(entryResults + children))
    return func.with(newResult, {models = newResult.models + conn + entryConns})
end

function data()
    return {
        type = "RAIL_STATION",
        buildMode = "SINGLE",
        availability = {
            yearFrom = 0,
            yearTo = 0
        },
        description = {
            name = _("Assembler"),
            description = _("description")
        },
        order = 5011,
        params = params(),
        updateFn = updateFn
    }
end
